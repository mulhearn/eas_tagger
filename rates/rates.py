import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize
import seaborn as sns
from hist1d import hist1d
from hist2d import hist2d
import sys

################################################################################################################################
################################################################################################################################
################################################################################################################################
#  parameters

##### exp parameters
data_period = 30 * 24* 3600 # in seconds
trig_window = 1e-6 # in seconds
muon_rate = 140 # 140 muons/m^2/s

#### trig parameters
min_trigger_hits = 3
scint_size = 0.1 #m
scint_area = scint_size*scint_size # m^2
num_scint = 10
Ae_trig = scint_area # assumes eff=1
eta_trig = muon_rate * Ae_trig * trig_window # 140 muons/m^2/s * 2e-5 cm^2 sensor Ae * window
p_nohit_bg_trig = np.exp( - eta_trig)  # not dependent on anything, calculate it once

##### phone parameters # NOTE USED IN THIS CODE
min_hits = 3  # only reconstruct showers with this many phones hit
Ae = 2e-5 # meters^2
eta = muon_rate * Ae * trig_window # 140 muons/m^2/s * 2e-5 cm^2 sensor Ae * window
p_nohit_bg = np.exp( - eta)  # not dependent on anything, calculate it once

################################################################################################################################
################################################################################################################################
################################################################################################################################
# helper functions


# density of particle in the shower
#   N = number of particles
#   r = distance from shower center, in meters
def rho(N,r):

    s =1 # shower stage, s=1 is max
    r_M = 79 # meters, moliere radius in air

    p = ( N/(2*np.pi*r_M**2) )
    try:
        p = ( N/(2*np.pi*r_M**2)* ( (r/r_M)**(s-2))  * (  (1+r/r_M)**(s-4.5) ) ) # leaving out Gamma terms for now
    except ZeroDivisionError:
        print ("Caught Zero divison")
    return p

# prob to not have a hit at phone location given shower center (x0,y0) with N particles
def p_nohit( phone_x,phone_y, x0,y0,N,trig=False,s_theta=0,s_phi=0):

    R = np.sqrt( (phone_x-x0)**2 + (phone_y - y0)**2)  # distance from the core along the detector plane

    det_phi = np.arctan2(phone_y-y0,phone_x-x0) # our angle in detector plane

    # distance from shower core, along axis perpendicular to original particle projection
    dr = 0.5*R * np.sqrt(3.0-np.cos(2*(det_phi-s_phi)) + 2*np.cos(det_phi-s_phi)*np.cos(det_phi-s_phi)*np.cos(2*s_theta));
    
    if (trig):
        p= np.exp( - eta_trig - Ae_trig*rho(N,dr) ) # prob of zero hits from poisson
    else:
        p= np.exp( - eta - Ae*rho(N,dr) ) # prob of zero hits from poisson
    return p



# generate a shower at x_0,y_0 with N particles onto phone array p_in
# trig=False means use phone performance; trig = True means use trigger performance

def gen_shower(N,x0,y0,theta,phi,p,trig=False):

    for phone in p:

        # prob of no hit on this phone
        p_nohit0 = p_nohit( phone[0], phone[1],x0,y0,N,trig,theta,phi)

        # random number to see a hit
        if (np.random.rand() > p_nohit0):
            phone[2] = 1
        else:
            phone[2] = 0
    return p

# simplified version for bg shower
# trig=False means use phone performance; trig = True means use trigger performance
def gen_bg(p,trig=False):

    # random values
    vals = np.random.rand(len(p))

    # compare to no hit prob
    if (trig):
        hits = [ 1 if x>p_nohit_bg_trig else 0 for x in vals]
    else:
        hits = [ 1 if x>p_nohit_bg else 0 for x in vals]


    # assign as a slice
    p[:,2] = hits

    return p

#####
##
## EAS rate vs energy is implemented as piece-wise interpolation from CR data

import pandas as pd
from scipy.interpolate import interp1d
# load data for interpolation, generated by plot_cr_rates.py, which uses data extracted by cr_rates.py from 
#    tutorial : https://github.com/crdb-project/tutorial/blob/main/gallery.ipynb
#    data: "All Particles" from Fig2 of https://arxiv.org/pdf/2306.08901
df = pd.read_csv("eas_rate_forinterp.csv")
# input is logE in GeV, output is rate x E in 1/(m^2 s sr)
eas_rate_gev = interp1d(df['logE_GeV'],df['rate_x_E'],kind='linear')

# rate of EAS at energy E in eV
# number per m^2 per second 
#  uses interpolation function defined above
def eas_rate_eV(E_eV):


    logE_eV = np.log10(E_eV) # rates use logE
    logE_GeV = logE_eV - 9 
    rate = eas_rate_gev(logE_GeV) * 3.14159 * 1.5  # integrate over steradians, result now in 1/(m^2 s)
    return rate 

def check_eas_rate():

    logE_eVs = np.linspace(14.0,20.0,18)
    for logE in logE_eVs:
        print(" ================== ")
        print(" log E = ", logE, " eV")
        print(" log E = ", logE-9, " GeV")
        E_eV = 10**logE
        print("     E = ",E_eV," eV")
        print("     E = ",E_eV/1e9," GeV")
        print("      rate = ", eas_rate_eV(E_eV))


# choose an energy from the EAS spectrum 
def gen_energy(min_E,norm):

    # find max over range, will be at min
    max = eas_rate_eV(min_E)/norm    

    while (True):

        # generate test e
        test_e = np.random.uniform(min_E, 1e20)
        
        # calcualte prob
        p = eas_rate_eV(test_e) / norm
        
        # toss random to keep it
        if (np.random.uniform(0,max) < p):
            return test_e

# choose an energy from the EAS spectrum, no rejection, weighting
def gen_energy_weighted(min_E,max_E=1e20):

    # find max over range, will be at min
    max = eas_rate_eV(min_E)

    # generate test e
    test_e = np.random.uniform(min_E, max_E)
        
    # calcualte prob
    return test_e, eas_rate_eV(test_e) / max
            
# number of muons+antimuons in the shower depending on energy in eV
def part_mult(E_eV):

    E_GeV = E_eV/1e9

    # mapping was in GeV
    s_loge=np.log(E_GeV)
    s_logn_mu = -3.57 +0.93*s_loge  #  from corsika study, see energy_v_N_muon_lowcut.pdf
    N = np.exp(s_logn_mu)
    
    return N

# inverse of above, from N get energy
def energy(N):

    logn = np.log(N)
    loge = (logn+3.57) / 0.93 
    E_GeV = np.exp(loge)
    E_eV = E_GeV*1e9
    return E_eV

# build an array of scintillators 'dist' apart in two rows
def build_array(dist):

    array = np.zeros(shape=(num_scint,3))  # each one is (x,y, hit/nothit)
    pi=0

    # two rows, "dist" apart in x, stacked by size in y
    max_y = (num_scint/4.0)*scint_size
    for i in range(int(num_scint/2)):
        array[pi] = [-dist/2, -max_y + i*scint_size,0]
        pi = pi + 1
        array[pi] = [dist/2,  -max_y + i*scint_size,0]
        pi = pi + 1

    #for a in array:
    #    print (" scint at ( %1.2f,%1.2f) "%(a[0],a[1]))

    return array



################################################################################################################################
################################################################################################################################
################################################################################################################################
# predict hit and energy distributions for various configurations


# Calculate the number of tagger hits expected for several dists, and make plots
#    dist = distance (m) between scint blocks, assuming n=2
#    number of taggers is controlled by parameters above

def trig_hits( dists,colors ):
    ehs = []
    nh_ss = []
    nh_noss = []

    # loop over distances
    for dist,color in zip(dists,colors):

        # call for this distance
        nh_shower_h,nh_noshower_h, e_shower_h = trig_hits_dist(dist)
        ehs.append(e_shower_h)
        nh_ss.append(nh_shower_h)
        nh_noss.append(nh_noshower_h)
        nh_shower_h.draw(label='EAS dist=%d'%dist,color=color)
        nh_noshower_h.draw(label='Bkg dist=%d'%dist,linestyle=':',color=color)

    # bunch of plotting stuff
    plt.yscale("log")
    plt.xlabel("Tagger hits")
    plt.ylabel("Number per %d days"%int(data_period/(24*3600)))
    plt.ylim(1e-6,1e9)
    plt.legend()
    plt.savefig("trig_nh_dist_numscint%d.pdf"%num_scint)
    plt.clf()

    # cumulative version
    for (nh_shower_h,nh_noshower_h,color) in zip (nh_ss,nh_noss,colors):
        nh_shower_h.draw_cumsum(label='EAS dist=%d'%dist,color=color)
        nh_noshower_h.draw_cumsum(label='Bkg dist=%d'%dist,linestyle=':',color=color)
    plt.yscale("log")
    plt.xlabel("Min tagger hits")
    plt.ylabel("Number per %d days"%int(data_period/(24*3600)))
    plt.ylim(1e-6,1e9)
    plt.legend()
    plt.savefig("trig_cumsum_nh_dist_numscint%d.pdf"%num_scint)
    plt.clf()
    
    for eh,dist,color in zip(ehs,dists,colors):
        eh.draw(label='EAS dist=%d'%dist,color=color)
    plt.yscale("log")
    plt.xlabel("Shower E")
    plt.ylabel("Number per %d days"%int(data_period/(24*3600)))
    plt.legend()
    plt.savefig("trig_e_dist_numscint%d.pdf"%num_scint)
    plt.clf()


# Calculate the expected number of hits for a specific distance 
def trig_hits_dist( dist):

    print ("Distances = ",dist)
    
    # build an array of scintillators
    array = build_array(dist)

    # ignore showers below this energy
    min_E  = 1e16
    
    # how many showers do we expect above our min E?
    eas_rate = eas_rate_eV(min_E) # per m^2 per second

    # sim area is the size of the ground where we have >0 efficiency, the showers we need to simulate
    #   this is bigger than the array or scint area since we have efficiency from showers where core does not hit array
    sim_size = 2000 #m
    sim_area = sim_size*sim_size # m^2  just a guess for now, if big enough, should not be sensitive to this, just slow

    n_eas_showers = eas_rate * sim_area * data_period  # number hitting the full area of the array
    print (" Rate = ", eas_rate, " per m2 per s")
    print (" m2 s = ", sim_area * data_period)
    print ("Number of showers = ",n_eas_showers)

    # hists to keep track of results
    nh_shower_h = hist1d(num_scint+1,-0.5,num_scint+0.5)
    e_shower_h = hist1d(40,np.log10(min_E),20.0)

    # reduce the number to simulate by this, then scale up with weights
    #  sig_scale = 10 means 10:1 data:mc ratio
    #  sig_scale = 0.1 means 1:10 data:mc ratio
    sig_scale = 0.2

    # loop over showers
    for i in range(int(n_eas_showers/sig_scale)):

        if (i%1000==0):
            print ("Shower ", i,"/",int(n_eas_showers/sig_scale))

        # generate energy, calc N
        E0,e_weight = gen_energy_weighted(min_E)
        N0 = part_mult(E0)

        # put it randomly across sim region
        x0 = np.random.uniform(-sim_size/2,sim_size/2)
        y0 = np.random.uniform(-sim_size/2,sim_size/2)

        # angles
        theta = np.random.normal(scale=0.2) # should prob be some cosine thing
        phi = np.random.uniform(0,2*np.pi)

        # generate a shower
        params = [N0,x0,y0,theta,phi]
        sh = gen_shower( *params, array,True) # trig=True to use trigger performance
        num_hits = np.sum(sh[:,2])
        nh_shower_h.fill(num_hits,weight=sig_scale*e_weight)
        if (num_hits >= min_trigger_hits):
            e_shower_h.fill(np.array([np.log10(E0)]),weight=sig_scale*e_weight)


    #### background
    
    ## First estimate trigger rates without MC
    # trigger rate
    print (" p_nohit_bg_trig = ", p_nohit_bg_trig)
    nh_noshower_h = hist1d(num_scint+1,-0.5,num_scint+0.5)

    # no need to do MC here, just calculate it
    # background rates don't depend on location, don't need MC
    for h in range(num_scint):

        prob_nhits = scipy.stats.binom.pmf(h,num_scint, 1.0-p_nohit_bg_trig)
        rate_nhits = prob_nhits * (data_period / trig_window)  # prob * number of trigger windows
        print ("nhits = ",h, " prob = ",prob_nhits," rate = ", rate_nhits)        
        nh_noshower_h.fill(np.array([h]),weight=rate_nhits)

    return nh_shower_h,nh_noshower_h, e_shower_h

################################################################################################################################
################################################################################################################################
################################################################################################################################
#  meausure shower efficiency as function of energy and distance

def trig_hits_eff( dists):

    effs = []
    e_centers = []
    for dist in dists:
        eff, e_center = trig_hits_eff_dist(dist)
        effs.append(eff)
        e_centers.append(e_center)
        print(" e centers = ",e_center, " effs = ", eff)

    for eff,e_center,dist in zip(effs,e_centers,dists):
        plt.plot(e_center,eff,label='dist=%d'%dist)

    plt.legend()
    plt.xscale("log")
    plt.xlabel("Shower Energy [eV]")
    plt.ylabel("Tagger efficiency (>= %d/%d hits)"%(min_trigger_hits,num_scint))
    plt.savefig("trig_eff_numscint%d.pdf"%num_scint)
    plt.clf()

def trig_hits_eff_dist( dist ): 

    print ("Distances = ",dist)

    # build an array of scintillators
    array = build_array(dist)
   
    # ignore showers below this energy
    E_bins = [5e15,1e16,5e16,1e17,5e17,1e18,5e18,1e19,5e19]
    num_E = len(E_bins)

    # sim area is the size of the ground where we have >0 efficiency, the showers we need to simulate
    #   this is bigger than the array or scint area since we have efficiency from showers where core does not hit array
    sim_size = 100
    sim_area = sim_size*sim_size # m^2  just a guess for now, if big enough, should not be sensitive to this, just slow

    # hists to keep track of results
    nh_e_shower_h2 = hist2d(E_bins,num_scint,0,num_scint)

    # loop over showers
    for i in range(10000):

        # choose evenly among bins, not whole range, since its log scale
        ebin = int(np.random.uniform(0,num_E-1))
        # now choose energy within bin
        E0, e_weight = gen_energy_weighted(E_bins[ebin],E_bins[ebin+1])   #np.random.uniform(E_bins[ebin],E_bins[ebin+1])
        N0 = part_mult(E0)

        # put it randomly across sim region
        x0 = np.random.uniform(-sim_size/2,sim_size/2)
        y0 = np.random.uniform(-sim_size/2,sim_size/2)

        # angles
        theta = np.random.normal(scale=0.2) # should prob be some cosine thing
        phi = np.random.uniform(0,2*np.pi)

        # generate a shower
        params = [N0,x0,y0,theta,phi]
        sh = gen_shower( *params, array,True) # trig=True to use trigger performance
        num_hits = np.sum(sh[:,2])
        nh_e_shower_h2.fill([E0,num_hits],e_weight)

    e_centers = nh_e_shower_h2.centersx
    effs = []
    for i in range(num_E-1):
        y_data = nh_e_shower_h2.histys[i]
        eff = y_data[min_trigger_hits:].sum()/y_data.sum()
        print ("E = ",e_centers[i], " hit data = ",y_data/y_data.sum(), " eff = ", eff)

        plt.stairs(y_data/y_data.sum(),nh_e_shower_h2.ybins,label="E=%1.2e"%e_centers[i])

        effs.append(eff)
    plt.legend()
    plt.xlabel("Number of hits")
    plt.ylabel("Fraction")
    plt.savefig("trig_nhits_dist%1.2f_numscint%d.pdf"%(dist,num_scint))
    plt.clf()

    return effs, e_centers







#trig_hits([1,20,100,200], ['black','red','green','blue'])
trig_hits_eff([ 1,20,100,200])
